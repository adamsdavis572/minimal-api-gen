# Contract: .csproj File Structure for NuGet Packaging

**Feature**: 008-nuget-api-contracts  
**Status**: Draft  
**Purpose**: Document the structure and content of both .csproj files (Contracts and Implementation) generated by Feature 008

---

## Overview

Feature 008 uses a "unified generation" approach where source files are generated once in a shared `Generated/` directory, and two separate `.csproj` files reference them:

1. **Contracts.csproj**: Packages API surface layer (Endpoints, DTOs, Validators) for NuGet distribution
2. **Implementation.csproj**: Contains business logic (Handlers, Models, Program.cs) and references Contracts project

**Key Architecture Decision** (from RQ-001 in research.md): Files are generated once and referenced via `<Compile Include>` with relative paths using Link metadata. This avoids file duplication and ensures consistency.

---

## Directory Structure (Generated Output)

```text
test-output/
  Generated/
    Models/
      Pet.cs
      Order.cs
      User.cs
    Endpoints/
      PetEndpoints.cs
      StoreEndpoints.cs
      UserEndpoints.cs
    Validators/                    (if useValidators=true)
      PetValidator.cs
      OrderValidator.cs
    Commands/                      (MediatR requests)
      AddPetCommand.cs
      UpdatePetCommand.cs
    Queries/
      GetPetByIdQuery.cs
      FindPetsByStatusQuery.cs
  src/
    PetstoreApi.Contracts/
      PetstoreApi.Contracts.csproj (references ../../Generated/...)
      Extensions/
        EndpointExtensions.cs      (AddApiEndpoints method)
        ValidatorExtensions.cs     (AddApiValidators method, if useValidators=true)
    PetstoreApi/
      PetstoreApi.csproj           (references Contracts project + local files)
      Program.cs                   (user-owned, service registration)
      Handlers/                    (user-owned, IRequestHandler implementations)
        AddPetCommandHandler.cs
        GetPetByIdQueryHandler.cs
        ...
      Models/                      (user-owned, business entities)
        InMemoryPetStore.cs        (example)
```

**Rationale** (from research.md RQ-005):
- Generated files live in `Generated/` directory (single source of truth)
- Clear separation between generated code and user-owned code
- Supports `.gitignore Generated/` pattern for clean source control
- `<Compile Include>` with Link metadata preserves logical structure in Solution Explorer

---

## Contracts Project (.csproj)

### File Location
`test-output/src/PetstoreApi.Contracts/PetstoreApi.Contracts.csproj`

### Full Structure
```xml
<Project Sdk="Microsoft.NET.Sdk">
  
  <!-- Basic Project Properties -->
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- NuGet Package Metadata (FR-016) -->
  <PropertyGroup>
    <!-- Core identification -->
    <PackageId>{{packageId}}</PackageId>
    <Version>{{packageVersion}}</Version>
    <Authors>{{packageAuthors}}</Authors>
    <Company>{{packageAuthors}}</Company>
    <Description>{{packageDescription}}</Description>
    
    <!-- Licensing -->
    <PackageLicenseExpression>Apache-2.0</PackageLicenseExpression>
    
    <!-- Repository metadata -->
    <RepositoryUrl>{{packageRepositoryUrl}}</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageProjectUrl>{{packageProjectUrl}}</PackageProjectUrl>
    
    <!-- Discoverability -->
    <PackageTags>openapi;minimal-api;contracts;{{packageName}}</PackageTags>
    <PackageReadmeFile>README.md</PackageReadmeFile>
    
    <!-- Packaging behavior (FR-003) -->
    <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
    
    <!-- Symbol packages for debugging (FR-015, US5) -->
    {{#includeSymbols}}
    <IncludeSymbols>true</IncludeSymbols>
    <SymbolPackageFormat>snupkg</SymbolPackageFormat>
    {{/includeSymbols}}
  </PropertyGroup>

  <!-- Package Dependencies (FR-004) -->
  <ItemGroup>
    <!-- MediatR for Commands/Queries (REQUIRED) -->
    <PackageReference Include="MediatR" Version="12.2.0" />
    <PackageReference Include="MediatR.Contracts" Version="2.0.1" />
    
    <!-- ASP.NET Core for Minimal API endpoints -->
    <PackageReference Include="Microsoft.AspNetCore.OpenApi" Version="8.0.0" />
    
    <!-- FluentValidation (CONDITIONAL on useValidators) -->
    {{#useValidators}}
    <PackageReference Include="FluentValidation" Version="11.9.0" />
    <PackageReference Include="FluentValidation.DependencyInjectionExtensions" Version="11.9.0" />
    {{/useValidators}}
  </ItemGroup>

  <!-- Generated Source Files (FR-002 - Unified References, RQ-001) -->
  <ItemGroup>
    <!-- DTOs from Generated/ directory -->
    <Compile Include="..\..\Generated\Models\*.cs" Link="Models\%(Filename)%(Extension)" />
    
    <!-- MediatR Commands from Generated/ directory -->
    <Compile Include="..\..\Generated\Commands\*.cs" Link="Commands\%(Filename)%(Extension)" />
    
    <!-- MediatR Queries from Generated/ directory -->
    <Compile Include="..\..\Generated\Queries\*.cs" Link="Queries\%(Filename)%(Extension)" />
    
    <!-- Endpoints from Generated/ directory -->
    <Compile Include="..\..\Generated\Endpoints\*.cs" Link="Endpoints\%(Filename)%(Extension)" />
    
    <!-- Validators from Generated/ directory (CONDITIONAL) -->
    {{#useValidators}}
    <Compile Include="..\..\Generated\Validators\*.cs" Link="Validators\%(Filename)%(Extension)" />
    {{/useValidators}}
  </ItemGroup>

  <!-- Extension Methods (Local to project, FR-007, FR-008) -->
  <ItemGroup>
    <Compile Include="Extensions\EndpointExtensions.cs" />
    {{#useValidators}}
    <Compile Include="Extensions\ValidatorExtensions.cs" />
    {{/useValidators}}
  </ItemGroup>

  <!-- Package README (Optional) -->
  <ItemGroup>
    <None Include="README.md" Pack="true" PackagePath="\" />
  </ItemGroup>

</Project>
```

---

### Metadata Properties Explained

#### Core Identification (REQUIRED)
- **PackageId**: Unique identifier on NuGet feeds (e.g., `PetstoreApi.Contracts`)
  - Default: `{packageName}.Contracts`
  - Maps to CLI option: `packageId`
- **Version**: SemVer 2.0.0 version (e.g., `1.2.0`, `2.0.0-beta`)
  - Default: `1.0.0`
  - Maps to CLI option: `packageVersion`
- **Authors**: Package creator(s) for attribution (e.g., `Platform Team`)
  - Default: `Generated by OpenAPI Generator`
  - Maps to CLI option: `packageAuthors`

#### Description & Discoverability (STRONGLY RECOMMENDED)
- **Description**: Human-readable package purpose, shown on nuget.org
  - Default: Auto-generated from `packageName`
  - Maps to CLI option: `packageDescription`
- **PackageTags**: Semicolon-separated keywords for search (e.g., `openapi;minimal-api;contracts`)
  - Improves discoverability on NuGet feeds
- **Company**: Defaults to `Authors` value for consistency

#### Licensing (RECOMMENDED)
- **PackageLicenseExpression**: SPDX license identifier (e.g., `Apache-2.0`, `MIT`)
  - Required for public NuGet.org publishing
  - Alternative: `<PackageLicenseFile>` for custom licenses

#### Repository Integration (RECOMMENDED)
- **RepositoryUrl**: GitHub/GitLab/Azure DevOps URL (e.g., `https://github.com/org/repo`)
  - Enables "View on GitHub" link on nuget.org
  - Supports source link debugging
- **RepositoryType**: Version control system (`git`, `svn`, `hg`)
- **PackageProjectUrl**: Documentation or project homepage URL

#### Packaging Behavior (IMPORTANT)
- **GeneratePackageOnBuild**: `false` (FR-003)
  - Forces explicit `dotnet pack` command
  - Prevents accidental package generation during development builds
- **IncludeSymbols**: `true` when `includeSymbols=true` CLI option set (FR-015)
  - Generates `.snupkg` symbol package alongside `.nupkg`
- **SymbolPackageFormat**: `snupkg` (modern format, recommended over legacy `symbols.nupkg`)

---

### File Inclusion Patterns (RQ-001 Research Decision)

#### Pattern: `<Compile Include>`
```xml
<Compile Include="..\..\Generated\Models\*.cs" Link="Models\%(Filename)%(Extension)" />
```

**Breakdown**:
- **Include**: Relative path from .csproj to source files
  - `..\..\Generated\Models\*.cs` = "Go up 2 levels, find Generated/Models/, include all .cs files"
  - Wildcard `*.cs` enables adding new files without .csproj edits
- **Link**: Logical path in Solution Explorer/IDE
  - `Models\%(Filename)%(Extension)` = "Display files under Models/ folder"
  - `%(Filename)` and `%(Extension)` are MSBuild metadata (preserves original filename)
- **Result**: Files physically at `../../Generated/Models/Pet.cs` appear as `Models/Pet.cs` in IDE

**Why this approach** (from research.md RQ-001):
- Standard MSBuild pattern (widely supported)
- No file duplication on disk (single source of truth)
- Link metadata preserves logical directory structure in IDE
- Wildcards enable adding new DTOs/Endpoints without regenerating .csproj

#### Alternative Pattern: Recursive Wildcards
```xml
<Compile Include="..\..\Generated\**\*.cs" LinkBase="." />
```
- `**\*.cs` matches all .cs files recursively
- `LinkBase="."` preserves subdirectory structure
- **Not used**: Less explicit, harder to control conditional inclusion (validators)

---

### Conditional Compilation (useValidators)

Feature 008 conditionally includes validators in the package based on `useValidators` CLI option:

```xml
{{#useValidators}}
<Compile Include="..\..\Generated\Validators\*.cs" Link="Validators\%(Filename)%(Extension)" />
{{/useValidators}}
```

**Effect**:
- `useValidators=true`: Validators included in Contracts.dll, FluentValidation dependency added
- `useValidators=false`: No validators in package, no FluentValidation dependency

**Rationale** (from FR-022):
- Validators are part of API contract (input validation rules)
- But not all APIs need validation (optional feature from Feature 007)
- Package adapts to configuration flags

---

## Implementation Project (.csproj)

### File Location
`test-output/src/PetstoreApi/PetstoreApi.csproj`

### Full Structure
```xml
<Project Sdk="Microsoft.NET.Sdk.Web">
  
  <!-- Basic Project Properties -->
  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <LangVersion>latest</LangVersion>
  </PropertyGroup>

  <!-- Reference to Contracts Project (FR-005) -->
  <ItemGroup>
    <!-- Local development: ProjectReference -->
    <ProjectReference Include="..\PetstoreApi.Contracts\PetstoreApi.Contracts.csproj" />
    
    <!-- Production deployment: Replace with PackageReference -->
    <!-- <PackageReference Include="PetstoreApi.Contracts" Version="1.0.0" /> -->
  </ItemGroup>

  <!-- Additional Dependencies (User-Added) -->
  <ItemGroup>
    <!-- MediatR handler registration -->
    <PackageReference Include="MediatR" Version="12.2.0" />
    
    <!-- Example: Database access (user adds) -->
    <!-- <PackageReference Include="Microsoft.EntityFrameworkCore" Version="8.0.0" /> -->
    
    <!-- Example: Caching (user adds) -->
    <!-- <PackageReference Include="Microsoft.Extensions.Caching.Memory" Version="8.0.0" /> -->
  </ItemGroup>

  <!-- User-Owned Code (FR-006) -->
  <ItemGroup>
    <!-- Main entry point -->
    <Compile Include="Program.cs" />
    
    <!-- Handler implementations (MediatR IRequestHandler<,>) -->
    <Compile Include="Handlers\**\*.cs" />
    
    <!-- Business entities (domain models) -->
    <Compile Include="Models\**\*.cs" />
  </ItemGroup>

</Project>
```

---

### Project Reference vs Package Reference (FR-005)

#### Development Mode (Default)
```xml
<ProjectReference Include="..\PetstoreApi.Contracts\PetstoreApi.Contracts.csproj" />
```

**Behavior**:
- References local Contracts project in solution
- Changes to Contracts code immediately visible
- Both projects build together in Visual Studio/Rider
- No need to pack/publish for local development
- **Use case**: Active development, both projects in same repository

#### Production Mode (Manual Switch)
```xml
<PackageReference Include="PetstoreApi.Contracts" Version="1.0.0" />
```

**Behavior**:
- References published NuGet package from feed
- Contracts code treated as external dependency
- `dotnet restore` downloads from NuGet feed
- Version pinning for reproducible builds
- **Use case**: Deploying implementation without Contracts source code

**Migration path** (from spec assumptions):
1. Develop with `ProjectReference` (both projects local)
2. Publish Contracts to NuGet feed: `dotnet pack` → `dotnet nuget push`
3. Switch Implementation to `PackageReference` for deployment
4. Update package version when API changes

---

### User-Owned Code (FR-006)

Implementation project contains files that are **user-owned** (not generated):

#### Program.cs (Entry Point)
```csharp
var builder = WebApplication.CreateBuilder(args);

// Register MediatR handlers from this assembly (FR-009, FR-021)
builder.Services.AddMediatR(cfg => 
    cfg.RegisterServicesFromAssembly(typeof(Program).Assembly));

// Register validators from Contracts assembly (FR-008, RQ-004)
{{#useValidators}}
builder.Services.AddApiValidators();
{{/useValidators}}

var app = builder.Build();

// Register endpoints from Contracts package (FR-007)
app.AddApiEndpoints();

app.Run();
```

**Key points**:
- Program.cs is **NOT regenerated** (preserves user customizations)
- Users add custom service registrations (DbContext, caching, auth)
- Uses extension methods from Contracts package (AddApiEndpoints, AddApiValidators)

#### Handlers/ Directory (Business Logic)
```text
Handlers/
  AddPetCommandHandler.cs
  UpdatePetCommandHandler.cs
  GetPetByIdQueryHandler.cs
  ...
```

Each handler implements `IRequestHandler<TRequest, TResponse>`:
```csharp
public class AddPetCommandHandler : IRequestHandler<AddPetCommand, Pet>
{
    private readonly IDbContext _dbContext; // User injected service
    
    public AddPetCommandHandler(IDbContext dbContext)
    {
        _dbContext = dbContext;
    }
    
    public async Task<Pet> Handle(AddPetCommand request, CancellationToken cancellationToken)
    {
        // Business logic implementation
        var pet = new Pet { Id = request.Id, Name = request.Name };
        await _dbContext.Pets.AddAsync(pet);
        await _dbContext.SaveChangesAsync();
        return pet;
    }
}
```

**Key points** (from FR-021):
- Handlers are **user-owned** (not generated after initial scaffold)
- MediatR's `AddMediatR(cfg => cfg.RegisterServicesFromAssembly(typeof(Program).Assembly))` auto-discovers handlers
- Users can add custom handlers (not from OpenAPI) without regeneration
- Handlers are in **same assembly** as Program.cs (allows `typeof(Program).Assembly`)

#### Models/ Directory (Domain Entities)
```text
Models/
  InMemoryPetStore.cs
  DatabaseContext.cs
  ...
```

User-defined classes for business logic (repositories, services, domain models).

---

## Comparison Matrix: Contracts vs Implementation

| Aspect | Contracts.csproj | Implementation.csproj |
|--------|-----------------|----------------------|
| **SDK** | `Microsoft.NET.Sdk` | `Microsoft.NET.Sdk.Web` |
| **Purpose** | NuGet package for distribution | Runnable web application |
| **NuGet Metadata** | Full metadata (PackageId, Version, etc.) | No metadata (not packaged) |
| **Generated Files** | References via `<Compile Include>` | None (references Contracts) |
| **User Code** | Extension methods only | Program.cs, Handlers/, Models/ |
| **Dependencies** | MediatR, FluentValidation, ASP.NET Core | Contracts package + user-added deps |
| **Output** | `.dll` (library) → packaged as `.nupkg` | `.exe` (web app) |
| **Build Command** | `dotnet build` → compiles library | `dotnet build` → runnable app |
| **Pack Command** | `dotnet pack` → generates `.nupkg` | N/A (not packaged) |
| **Deployment** | Published to NuGet feed | Deployed as web service |
| **Versioning** | SemVer (follows API changes) | No versioning (internal app) |
| **Consumers** | Other projects/teams via NuGet | End users via HTTP |

---

## Assembly Separation (FR-022)

Feature 008 splits components across two assemblies:

### Contracts.dll (Distributed via NuGet)
```text
PetstoreApi.Contracts.dll
├── Models/          (DTOs: Pet, Order, User)
├── Commands/        (MediatR IRequest: AddPetCommand, UpdatePetCommand)
├── Queries/         (MediatR IRequest: GetPetByIdQuery, FindPetsByStatusQuery)
├── Endpoints/       (Minimal API routes: PetEndpoints, StoreEndpoints)
├── Validators/      (FluentValidation: PetValidator, OrderValidator) [optional]
└── Extensions/      (DI registration: EndpointExtensions, ValidatorExtensions)
```

**Why packaged**: API surface layer, versioned independently, consumed by multiple implementations

### Implementation.dll (Host Application)
```text
PetstoreApi.dll
├── Program.cs       (Entry point, service registration)
├── Handlers/        (MediatR IRequestHandler: AddPetCommandHandler, GetPetByIdQueryHandler)
└── Models/          (Business entities: InMemoryPetStore, DbContext)
```

**Why NOT packaged**: Business logic, implementation-specific, tightly coupled to infrastructure

**Rationale** (from FR-022):
- Endpoints/DTOs/Validators define **what** the API does (contract)
- Handlers/Models define **how** the API works (implementation)
- Separation enables independent versioning and testing
- Validators need special registration (different assembly than Program.cs)
- Handlers use `typeof(Program).Assembly` (same assembly as Program.cs)

---

## Build and Pack Workflow

### Step 1: Generate Code
```bash
cd /Users/adam/scratch/git/minimal-api-gen
devbox run task generate-petstore-minimal-api ADDITIONAL_PROPS="packageName=PetstoreApi,useNugetPackaging=true,packageVersion=1.0.0"
```

**Output**:
- `Generated/` directory with source files
- `src/PetstoreApi.Contracts/PetstoreApi.Contracts.csproj`
- `src/PetstoreApi/PetstoreApi.csproj`

---

### Step 2: Build Contracts Project
```bash
devbox run -- dotnet build test-output/src/PetstoreApi.Contracts/ --configuration Release
```

**Output**:
- `bin/Release/net8.0/PetstoreApi.Contracts.dll`
- Compilation errors if any generated code is invalid

---

### Step 3: Pack Contracts Project (FR-018)
```bash
devbox run -- dotnet pack test-output/src/PetstoreApi.Contracts/ --configuration Release --output ./nupkgs/
```

**Output**:
- `nupkgs/PetstoreApi.Contracts.1.0.0.nupkg` (binaries)
- `nupkgs/PetstoreApi.Contracts.1.0.0.snupkg` (symbols, if `includeSymbols=true`)

---

### Step 4: Publish to NuGet Feed (Manual)
```bash
# Publish to nuget.org
devbox run -- dotnet nuget push nupkgs/PetstoreApi.Contracts.1.0.0.nupkg --api-key YOUR_API_KEY --source https://api.nuget.org/v3/index.json

# Or publish to private Azure Artifacts feed
devbox run -- dotnet nuget push nupkgs/PetstoreApi.Contracts.1.0.0.nupkg --api-key YOUR_PAT --source https://pkgs.dev.azure.com/org/project/_packaging/feed/nuget/v3/index.json
```

---

### Step 5: Build Implementation Project
```bash
devbox run -- dotnet build test-output/src/PetstoreApi/ --configuration Release
```

**Output**:
- `bin/Release/net8.0/PetstoreApi.dll` (web app)
- `bin/Release/net8.0/PetstoreApi.Contracts.dll` (referenced assembly)

---

### Step 6: Run Implementation
```bash
devbox run -- dotnet run --project test-output/src/PetstoreApi/
```

**Output**:
- Web server starts on http://localhost:5000
- Endpoints registered from Contracts.dll
- Handlers executed from Implementation.dll

---

## Validation and Testing

### Build Validation (FR-017)
```bash
# Both projects MUST compile successfully
dotnet build test-output/src/PetstoreApi.Contracts/
dotnet build test-output/src/PetstoreApi/
```

**Success criteria**:
- Exit code 0
- No compilation errors
- All warnings addressed (nullable, unused variables)

### Pack Validation (FR-018, SC-002)
```bash
dotnet pack test-output/src/PetstoreApi.Contracts/ --configuration Release
```

**Success criteria**:
- Exit code 0
- `.nupkg` file created
- Package size under 500KB (typical OpenAPI spec with 20 operations)
- Valid NuGet package structure (can be verified with `unzip -l`)

### Package Contents Verification (FR-002)
```bash
unzip -l nupkgs/PetstoreApi.Contracts.1.0.0.nupkg
```

**Expected contents**:
```text
lib/net8.0/PetstoreApi.Contracts.dll
lib/net8.0/PetstoreApi.Contracts.deps.json
PetstoreApi.Contracts.nuspec
[Content_Types].xml
_rels/.rels
```

**MUST NOT contain**:
- Handler implementations (AddPetCommandHandler.dll)
- Models (business entities)
- Program.cs (entry point)

---

## Performance Benchmarks (SC-009)

### Build Time
**Target**: Under 10 seconds on standard hardware (M1 MacBook, 16GB RAM)

Typical results:
- Contracts project: 3-5 seconds
- Implementation project: 2-4 seconds
- **Total**: 5-9 seconds ✅

### Pack Time
**Target**: Under 5 seconds

Typical results:
- `dotnet pack`: 2-3 seconds ✅

### Package Size (SC-002)
**Target**: Under 500KB for typical spec (20 operations, 10 DTOs)

Typical results:
- Base package (no validators): 80-150 KB ✅
- With validators: 120-200 KB ✅
- Symbol package (if enabled): +30-50 KB

---

## Related Documentation

- [spec.md](../spec.md) - Feature requirements and user stories
- [research.md](../research.md) - RQ-001 (file references), RQ-002 (NuGet metadata), RQ-005 (unified generation)
- [data-model.md](../data-model.md) - Entity 1 (NuGet Package Project), Entity 2 (Implementation Project)
- [CLI-Options.md](./CLI-Options.md) - Generator CLI options
- [ExtensionMethods.md](./ExtensionMethods.md) - DI registration API
