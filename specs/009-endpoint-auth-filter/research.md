# Research: Endpoint Authorization Filter Implementation

**Feature**: 009-endpoint-auth-filter  
**Date**: 2025-02-15  
**Status**: Phase 0 - Technical Research

## Research Areas

### RQ-001: How does IEndpointFilter work in ASP.NET Core Minimal APIs?

**Status**: Resolved

**Question**: How do we implement `IEndpointFilter` to intercept requests and perform authorization checks based on endpoint metadata?

**Findings**:

**IEndpointFilter Interface**:
```csharp
public interface IEndpointFilter
{
    ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next);
}
```

**Key Components**:
- `EndpointFilterInvocationContext`: Provides access to `HttpContext`, endpoint metadata, and arguments
- `EndpointFilterDelegate next`: The next filter in the pipeline (or the endpoint handler)
- Return `await next(context)` to proceed, or return early to short-circuit

**Usage Pattern**:
```csharp
public class PermissionEndpointFilter : IEndpointFilter
{
    private readonly IAuthorizationService _authorizationService;
    
    // Mapping of endpoint names to policy names
    private static readonly Dictionary<string, string> EndpointPolicies = new()
    {
        { "AddPet", "WriteAccess" },
        { "GetPetById", "ReadAccess" },
        // ... more mappings
    };
    
    public PermissionEndpointFilter(IAuthorizationService authorizationService)
    {
        _authorizationService = authorizationService;
    }
    
    public async ValueTask<object?> InvokeAsync(
        EndpointFilterInvocationContext context, 
        EndpointFilterDelegate next)
    {
        var httpContext = context.HttpContext;
        
        // Get endpoint name from metadata
        var endpointName = httpContext.GetEndpoint()?
            .Metadata
            .GetMetadata<EndpointNameMetadata>()?
            .EndpointName;
        
        // If no policy defined for this endpoint, allow
        if (endpointName == null || !EndpointPolicies.TryGetValue(endpointName, out var policyName))
        {
            return await next(context);
        }
        
        // Authorize based on policy
        var authResult = await _authorizationService.AuthorizeAsync(
            httpContext.User, 
            null, 
            policyName);
        
        if (!authResult.Succeeded)
        {
            return Results.Forbid();
        }
        
        return await next(context);
    }
}
```

**Decision**: Use `IEndpointFilter` with dictionary-based endpoint-to-policy mapping

**Rationale**: 
- Filters can intercept ALL requests to a route group
- Access to endpoint metadata via `HttpContext.GetEndpoint().Metadata`
- No modification to generated endpoint code required
- Dependency injection support for `IAuthorizationService`

**Alternatives Considered**:
- Attribute-based authorization (`[Authorize(Policy = "WriteAccess")]`): Rejected - requires modifying generated code
- Middleware-based authorization: Rejected - less granular, harder to map specific endpoints to policies
- Policy-based authorization with requirements: Rejected - over-engineered for simple claim-based checks

---

### RQ-002: How do we retrieve endpoint names from Minimal API metadata?

**Status**: Resolved

**Question**: Generated endpoints use `.WithName("AddPet")`. How do we retrieve this name at runtime in the filter?

**Findings**:

**EndpointNameMetadata**:
```csharp
var endpoint = httpContext.GetEndpoint();
var endpointName = endpoint?.Metadata.GetMetadata<EndpointNameMetadata>()?.EndpointName;
```

**How .WithName() Works**:
- `.WithName("AddPet")` internally calls `Add(new EndpointNameMetadata(name))`
- Metadata is attached to the `Endpoint` object
- Retrieved via `endpoint.Metadata.GetMetadata<T>()`

**Current Generator Template** (api.mustache line 144):
```mustache
.WithName("{{{vendorExtensions.operationIdPascalCase}}}")
```

**Example Endpoint Names from Petstore**:
- Pet: `AddPet`, `UpdatePet`, `DeletePet`, `GetPetById`, `FindPetsByStatus`, `FindPetsByTags`
- Store: `PlaceOrder`, `DeleteOrder`, `GetOrderById`, `GetInventory`
- User: `CreateUser`, `UpdateUser`, `DeleteUser`, `GetUserByName`, `LoginUser`, `LogoutUser`

**Decision**: Use `EndpointNameMetadata` to retrieve endpoint names in filter

**Rationale**: 
- Already generated by existing templates (no template changes needed)
- Standard ASP.NET Core metadata mechanism
- Provides stable identifiers for endpoint-to-policy mapping

**Alternatives Considered**:
- Custom metadata attribute: Rejected - `.WithName()` already provides what we need
- Route pattern matching: Rejected - fragile, breaks if routes change
- HTTP method + path matching: Rejected - requires maintaining path pattern mapping

---

### RQ-003: How do we apply filters to a route group?

**Status**: Resolved

**Question**: How do we apply `IEndpointFilter` to all endpoints in a route group without modifying individual endpoint registrations?

**Findings**:

**Route Group Filter Application**:
```csharp
var group = endpoints.MapGroup("/v2")
    .AddEndpointFilter<PermissionEndpointFilter>();  // Apply to ALL endpoints in group

// OR with inline filter:
var group = endpoints.MapGroup("/v2")
    .AddEndpointFilter(async (context, next) =>
    {
        // Filter logic here
        return await next(context);
    });
```

**Multiple Filters**:
Filters execute in order of registration:
```csharp
group
    .AddEndpointFilter<LoggingFilter>()      // Runs first
    .AddEndpointFilter<AuthenticationFilter>() // Runs second
    .AddEndpointFilter<AuthorizationFilter>()  // Runs third
```

**Decision**: Create `AddAuthorizedApiEndpoints()` extension method that applies filter to route group

**Implementation**:
```csharp
public static class AuthorizedEndpointExtensions
{
    public static IEndpointRouteBuilder AddAuthorizedApiEndpoints(this IEndpointRouteBuilder endpoints)
    {
        var group = endpoints.MapGroup("/v2")
            .AddEndpointFilter<PermissionEndpointFilter>();  // Filter applied HERE
        
        // Delegate to generated endpoint registrations
        PetEndpoints.MapPetEndpoints(group);
        StoreEndpoints.MapStoreEndpoints(group);
        UserEndpoints.MapUserEndpoints(group);
        
        return endpoints;
    }
}
```

**Rationale**: 
- Filter applies to entire route group automatically
- Generated `AddApiEndpoints()` remains unchanged (no authorization)
- Developers can choose: `AddApiEndpoints()` (no auth) or `AddAuthorizedApiEndpoints()` (with auth)
- Satisfies FR-012: "MUST provide an extension method IN ADDITION to the generated AddApiEndpoints"

**Alternatives Considered**:
- Modify generated `AddApiEndpoints()`: Rejected - violates immutability constraint
- Global middleware: Rejected - can't easily map specific endpoints to policies
- Individual endpoint filter registration: Rejected - requires modifying generated code

---

### RQ-004: How do we configure authentication and authorization policies?

**Status**: Resolved

**Question**: What configuration is needed in `Program.cs` to wire up authentication, authorization, and define policies?

**Findings**:

**Minimal Configuration for Testing** (JWT Bearer):
```csharp
// In Program.cs (generated by program.mustache)

// 1. Add services
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = builder.Configuration["Auth:Authority"];
        options.Audience = builder.Configuration["Auth:Audience"];
    });

builder.Services.AddAuthorization(options =>
{
    // Define ReadAccess policy
    options.AddPolicy("ReadAccess", policy => 
        policy.RequireClaim("permission", "read"));
    
    // Define WriteAccess policy
    options.AddPolicy("WriteAccess", policy => 
        policy.RequireClaim("permission", "write"));
});

// 2. Add middleware (ORDER MATTERS)
var app = builder.Build();

app.UseAuthentication();  // MUST come before UseAuthorization
app.UseAuthorization();

// 3. Register endpoints with filter
app.AddAuthorizedApiEndpoints();
```

**Existing Template Support**:
Checking `program.mustache` lines 1-80:
- Line 3: `{{#useAuthentication}}using Microsoft.AspNetCore.Authentication.JwtBearer;{{/useAuthentication}}`
- Lines 32-38: Authentication/authorization configuration already exists!

```mustache
{{#useAuthentication}}
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = builder.Configuration["Auth:Authority"];
        options.Audience = builder.Configuration["Auth:Audience"];
    });
builder.Services.AddAuthorization();{{/useAuthentication}}
```

**Decision**: 
1. Use existing `useAuthentication` flag to enable authentication/authorization middleware
2. Extend template to add policy definitions when `useAuthentication=true`
3. Add `.AddEndpointFilter<PermissionEndpointFilter>()` to route group in new extension method

**Template Modifications Needed**:
```mustache
{{#useAuthentication}}
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.Authority = builder.Configuration["Auth:Authority"];
        options.Audience = builder.Configuration["Auth:Audience"];
    });
builder.Services.AddAuthorization(options =>
{
    // Authorization policies for endpoint filter
    options.AddPolicy("ReadAccess", policy => policy.RequireClaim("permission", "read"));
    options.AddPolicy("WriteAccess", policy => policy.RequireClaim("permission", "write"));
});
{{/useAuthentication}}
```

**Rationale**: 
- Existing flag reduces implementation effort
- Policy configuration in Program.cs is standard ASP.NET Core pattern
- Keeps authorization logic centralized and visible

**Alternatives Considered**:
- Policy registration in filter constructor: Rejected - policies must be registered in DI container
- Convention-based policies: Rejected - explicit policies are clearer and more maintainable
- Attribute-based policies: Rejected - requires modifying generated code

---

### RQ-005: How do we test authorization in Bruno and xUnit tests?

**Status**: Resolved

**Question**: What changes are needed to test authentication/authorization in the existing test infrastructure?

**Findings**:

#### Bruno Testing (Integration Tests)

**Current State**: Bruno tests don't include authentication headers

**Required Changes**:
1. **Add authentication headers** to Bruno test requests:
```javascript
// In bruno test file: pet/add-pet-authorized.bru
headers {
  Authorization: Bearer eyJhbGc...  // JWT with "permission: write" claim
  Content-Type: application/json
}
```

2. **Create new test scenarios**:
- `add-pet-authorized.bru`: Test with write claim (should succeed)
- `add-pet-unauthorized.bru`: Test without write claim (should return 403)
- `get-pet-authorized.bru`: Test with read claim (should succeed)
- `get-pet-no-auth.bru`: Test without authentication (should return 401)

3. **Environment variables** for JWT tokens:
```json
// bruno.json environment
{
  "authTokenRead": "eyJhbGc...base64JWT...",
  "authTokenWrite": "eyJhbGc...base64JWT...",
  "authTokenNone": ""
}
```

#### xUnit Testing (Unit Tests)

**Current State**: Tests use `CustomWebApplicationFactory` with no authentication

**Existing Test Host**:
```csharp
public class CustomWebApplicationFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            services.AddSingleton<IPetStore, InMemoryPetStore>();
        });
    }
}
```

**Required Changes**:
1. **Add authentication services** to test host:
```csharp
public class AuthorizedWebApplicationFactory : WebApplicationFactory<Program>
{
    protected override void ConfigureWebHost(IWebHostBuilder builder)
    {
        builder.ConfigureServices(services =>
        {
            services.AddSingleton<IPetStore, InMemoryPetStore>();
            
            // Add test authentication scheme
            services.AddAuthentication("Test")
                .AddScheme<AuthenticationSchemeOptions, TestAuthHandler>("Test", options => { });
            
            services.AddAuthorization();
        });
    }
}
```

2. **Create test authentication handler**:
```csharp
public class TestAuthHandler : AuthenticationHandler<AuthenticationSchemeOptions>
{
    private readonly string _permission;
    
    public TestAuthHandler(string permission, /* ... */)
    {
        _permission = permission;
    }
    
    protected override Task<AuthenticateResult> HandleAuthenticateAsync()
    {
        var claims = new[] { new Claim("permission", _permission) };
        var identity = new ClaimsIdentity(claims, "Test");
        var principal = new ClaimsPrincipal(identity);
        var ticket = new AuthenticationTicket(principal, "Test");
        
        return Task.FromResult(AuthenticateResult.Success(ticket));
    }
}
```

3. **Test scenarios**:
```csharp
[Fact]
public async Task AddPet_WithWritePermission_ReturnsCreated()
{
    // Arrange
    var factory = new AuthorizedWebApplicationFactory("write");
    var client = factory.CreateClient();
    
    // Act
    var response = await client.PostAsJsonAsync("/v2/pet", newPet);
    
    // Assert
    response.StatusCode.Should().Be(HttpStatusCode.Created);
}

[Fact]
public async Task AddPet_WithoutWritePermission_ReturnsForbidden()
{
    // Arrange
    var factory = new AuthorizedWebApplicationFactory("read");  // Only read permission
    var client = factory.CreateClient();
    
    // Act
    var response = await client.PostAsJsonAsync("/v2/pet", newPet);
    
    // Assert
    response.StatusCode.Should().Be(HttpStatusCode.Forbidden);
}
```

**Decision**: 
1. Existing 45 tests continue using `CustomWebApplicationFactory` (no auth) - must pass unchanged
2. New authorization tests use `AuthorizedWebApplicationFactory` with test authentication handler
3. Bruno tests get new test files with authentication headers

**Rationale**: 
- Preserves existing tests (Test-Driven Refactoring principle)
- Separation of concerns: auth tests vs functional tests
- Test authentication handler simpler than real JWT tokens for unit tests

**Alternatives Considered**:
- Modify existing tests: Rejected - violates TDD principle (existing tests must pass unchanged)
- Use real JWT tokens in tests: Rejected - adds complexity, external dependency
- Mock IAuthorizationService: Rejected - doesn't test full authorization pipeline

---

## Research Summary

### Resolved Questions (5/5)

All technical unknowns resolved. No blockers identified.

### Key Decisions

1. **Filter Implementation**: Use `IEndpointFilter` with dictionary-based endpoint-to-policy mapping
2. **Endpoint Identification**: Use existing `EndpointNameMetadata` from `.WithName()` calls
3. **Filter Application**: New `AddAuthorizedApiEndpoints()` extension method applies filter to route group
4. **Policy Configuration**: Extend existing `useAuthentication` template flag, add policy definitions to program.mustache
5. **Testing Strategy**: 
   - Existing 45 tests remain unchanged (no auth)
   - New `AuthorizedWebApplicationFactory` for authorization tests
   - New Bruno test files with authentication headers

### Template Modifications Required

1. **program.mustache**: Extend `{{#useAuthentication}}` block to add policy definitions
2. **NEW: PermissionEndpointFilter.cs** (test artifact, later considered for generator)
3. **NEW: AuthorizedEndpointExtensions.cs** (test artifact, later considered for generator)
4. **NEW: AuthorizedWebApplicationFactory.cs** (test infrastructure)
5. **NEW: Bruno test files** with authentication scenarios

### Configuration Parameters

New CLI option for generator (future consideration):
- `useAuthentication=true` (already exists - enables JWT Bearer + authorization middleware)
- Potential: `endpointPolicies` (JSON mapping of endpoint names to policy names)

### Dependencies Validated

All required dependencies already present:
- ✅ ASP.NET Core 8.0 (IEndpointFilter, IAuthorizationService, EndpointNameMetadata)
- ✅ FluentValidation (existing)
- ✅ MediatR (existing)
- ✅ xUnit + FluentAssertions (existing)
- ✅ Bruno CLI (existing)

### Constitution Re-Check

✅ **All principles still satisfied**:
- Inheritance-First: Operating at generated code level, not generator
- Test-Driven Refactoring: Existing tests pass unchanged, new tests added
- Template Reusability: Model templates unchanged
- Phase-Gated Progression: Following /speckit.plan workflow
- Build Tool Integration: No tooling changes required

**Status**: Ready for Phase 1 (Design & Contracts)
