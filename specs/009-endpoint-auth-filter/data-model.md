# Phase 1: Data Model - Endpoint Authorization Filter

**Feature**: 009-endpoint-auth-filter  
**Date**: 2025-02-15  
**Input**: research.md technical decisions

## Overview

This feature introduces authorization filtering to Minimal API endpoints without modifying generated code. The data model consists of:

1. **Authorization Policies** - Security rules with claim requirements
2. **Endpoint Metadata** - Identifying information attached to routes
3. **Endpoint-to-Policy Mappings** - Configuration linking endpoints to policies
4. **Permission Claims** - User authorization attributes

## Entity Definitions

### 1. Authorization Policy

**Purpose**: Represents a security rule that must be satisfied for access

**Properties**:
- `Name`: String (e.g., "ReadAccess", "WriteAccess")
- `ClaimType`: String (e.g., "permission")
- `ClaimValue`: String (e.g., "read", "write")

**Structure** (ASP.NET Core):
```csharp
// Registered in Program.cs
builder.Services.AddAuthorization(options =>
{
    options.AddPolicy("ReadAccess", policy => 
        policy.RequireClaim("permission", "read"));
    
    options.AddPolicy("WriteAccess", policy => 
        policy.RequireClaim("permission", "write"));
});
```

**Validation Rules**:
- Policy name MUST be unique within the application
- At least one claim requirement MUST be defined
- Claim type and value are case-sensitive

**Lifecycle**:
- Created: At application startup in Program.cs
- Retrieved: Via `IAuthorizationService.AuthorizeAsync()` in filter
- Modified: Requires application restart

**Relationships**:
- **One-to-Many** with Endpoint-to-Policy Mappings (one policy can protect multiple endpoints)

---

### 2. Endpoint Name Metadata

**Purpose**: Stable identifier for a Minimal API endpoint

**Properties**:
- `EndpointName`: String (e.g., "AddPet", "GetPetById")
- `Endpoint`: Reference to ASP.NET Core `Endpoint` object

**Structure** (ASP.NET Core):
```csharp
// Generated by api.mustache template
.WithName("AddPet")  // Internally creates: new EndpointNameMetadata("AddPet")
```

**Validation Rules**:
- Endpoint name MUST be unique across the application
- Name MUST match PascalCase OpenAPI operationId
- Name MUST NOT be null or empty

**Lifecycle**:
- Created: During endpoint registration (startup)
- Retrieved: Via `httpContext.GetEndpoint().Metadata.GetMetadata<EndpointNameMetadata>()`
- Immutable: Cannot be changed after endpoint registration

**Relationships**:
- **One-to-One** with Endpoint Registration (each endpoint has exactly one name)
- **Many-to-One** with Endpoint-to-Policy Mappings (endpoint name is lookup key)

---

### 3. Endpoint-to-Policy Mapping

**Purpose**: Configuration that maps endpoint names to authorization policy names

**Properties**:
- `EndpointName`: String (key) - matches EndpointNameMetadata
- `PolicyName`: String (value) - matches Authorization Policy name

**Structure** (C# Dictionary):
```csharp
private static readonly Dictionary<string, string> EndpointPolicies = new()
{
    // Pet endpoints
    { "AddPet", "WriteAccess" },
    { "UpdatePet", "WriteAccess" },
    { "DeletePet", "WriteAccess" },
    { "GetPetById", "ReadAccess" },
    { "FindPetsByStatus", "ReadAccess" },
    { "FindPetsByTags", "ReadAccess" },
    
    // Store endpoints
    { "PlaceOrder", "WriteAccess" },
    { "DeleteOrder", "WriteAccess" },
    { "GetOrderById", "ReadAccess" },
    { "GetInventory", "ReadAccess" },
    
    // User endpoints
    { "CreateUser", "WriteAccess" },
    { "UpdateUser", "WriteAccess" },
    { "DeleteUser", "WriteAccess" },
    { "GetUserByName", "ReadAccess" },
    { "LoginUser", "ReadAccess" },
    { "LogoutUser", "ReadAccess" }
};
```

**Validation Rules**:
- `EndpointName` MUST match an existing endpoint's `.WithName()` metadata
- `PolicyName` MUST match a registered authorization policy
- If endpoint name not in dictionary, authorization is NOT enforced (allow by default)

**Lifecycle**:
- Created: Static initialization in `PermissionEndpointFilter` class
- Retrieved: Lookup via `EndpointPolicies.TryGetValue(endpointName, out var policyName)`
- Modified: Requires recompilation (hardcoded dictionary)

**Future Enhancement**: Consider external configuration (JSON file, database) for dynamic updates

**Relationships**:
- **Many-to-One** with Authorization Policies (multiple endpoints can use same policy)
- **One-to-One** with Endpoint Names (each mapping references one endpoint)

---

### 4. Permission Claim

**Purpose**: Authorization attribute attached to authenticated user

**Properties**:
- `Type`: String (constant: "permission")
- `Value`: String (enum-like: "read" or "write")

**Structure** (ClaimsPrincipal):
```csharp
// JWT payload example
{
  "sub": "user123",
  "name": "John Doe",
  "permission": "write"  // <-- Authorization claim
}

// Retrieved in code
var permissionClaim = httpContext.User.FindFirst("permission");
string permissionValue = permissionClaim?.Value; // "read" or "write"
```

**Validation Rules**:
- Claim type MUST be "permission" (case-sensitive)
- Claim value MUST be "read" or "write" (lowercase)
- User MAY have zero, one, or both permission claims

**Lifecycle**:
- Created: During authentication (JWT token validation)
- Retrieved: Via `httpContext.User.Claims` or `httpContext.User.FindFirst("permission")`
- Expires: When JWT token expires or user logs out

**Relationships**:
- **Many-to-Many** with Users (user can have multiple claims, claim applies to multiple users)
- **Used By** Authorization Policies (policies check for presence of specific claims)

---

## Data Flow

### Request Authorization Flow

```
1. HTTP Request arrives at endpoint
   ↓
2. Route matching identifies endpoint
   ↓
3. IEndpointFilter.InvokeAsync() executes
   ↓
4. Retrieve EndpointNameMetadata from context
   ↓
5. Lookup endpoint name in EndpointPolicies dictionary
   ↓
6. If no policy mapping exists → ALLOW (pass to next filter)
   ↓
7. If policy mapping exists:
   ↓
8. Call IAuthorizationService.AuthorizeAsync(user, policyName)
   ↓
9. Policy evaluates user claims
   ↓
10. Authorization succeeds → ALLOW (pass to next filter)
    Authorization fails → DENY (return 403 Forbidden)
```

### Configuration Flow

```
1. Application startup (Program.cs)
   ↓
2. Register authentication services (JwtBearer)
   ↓
3. Define authorization policies (ReadAccess, WriteAccess)
   ↓
4. Register IAuthorizationService (automatic)
   ↓
5. Add IEndpointFilter to route group
   ↓
6. Register endpoints with .WithName() metadata
   ↓
7. Filter uses static EndpointPolicies dictionary for mapping
```

## Entity Relationship Diagram

```
┌─────────────────────────┐
│  Authorization Policy   │
│  ─────────────────────  │
│  - Name: string         │
│  - ClaimType: string    │
│  - ClaimValue: string   │
└─────────────────────────┘
            ▲
            │ referenced by
            │ (many-to-one)
            │
┌─────────────────────────┐
│ Endpoint-to-Policy Map  │
│  ─────────────────────  │
│  - EndpointName: key    │◄────┐
│  - PolicyName: value    │     │
└─────────────────────────┘     │
            │                   │
            │ uses              │ maps to
            │ (one-to-one)      │ (one-to-one)
            ▼                   │
┌─────────────────────────┐     │
│  Endpoint Name Metadata │     │
│  ─────────────────────  │     │
│  - EndpointName: string │─────┘
└─────────────────────────┘
            ▲
            │ attached to
            │ (one-to-one)
            │
┌─────────────────────────┐
│   Minimal API Endpoint  │
│  ─────────────────────  │
│  - Route: string        │
│  - HttpMethod: string   │
│  - Handler: delegate    │
└─────────────────────────┘

┌─────────────────────────┐
│   Permission Claim      │
│  ─────────────────────  │
│  - Type: "permission"   │
│  - Value: "read"|"write"│
└─────────────────────────┘
            ▲
            │ attached to
            │ (many-to-many)
            │
┌─────────────────────────┐
│     ClaimsPrincipal     │
│  ─────────────────────  │
│  - User identity        │
│  - Claims collection    │
└─────────────────────────┘
```

## Implementation Notes

### Extensibility Points

1. **Policy Definitions**: Easy to add new policies (e.g., "AdminAccess" with "role: admin" claim)
2. **Endpoint Mappings**: Easy to add endpoint-to-policy mappings for new endpoints
3. **Claim Types**: Can extend to support multiple claim types (role, scope, etc.)

### Future Enhancements

1. **External Configuration**: Load EndpointPolicies from JSON/YAML file
2. **Dynamic Policies**: Support policy creation via API
3. **Hierarchical Claims**: Support "write" implies "read" logic
4. **Audit Logging**: Log authorization failures for security monitoring

### Configuration Example (appsettings.json - Future)

```json
{
  "Authentication": {
    "Authority": "https://auth.example.com",
    "Audience": "petstore-api"
  },
  "Authorization": {
    "EndpointPolicies": {
      "AddPet": "WriteAccess",
      "GetPetById": "ReadAccess",
      // ... more mappings
    }
  }
}
```

### Performance Considerations

- Dictionary lookup: O(1) average case (fast)
- Endpoint metadata retrieval: O(1) (cached by ASP.NET Core)
- Authorization evaluation: O(n) where n = number of claims (typically < 10)
- **Target**: < 5ms authorization overhead (SC-006)

---

**Status**: Complete - Ready for contract definitions
