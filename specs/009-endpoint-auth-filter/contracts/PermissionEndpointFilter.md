# Contract: PermissionEndpointFilter.cs

**Status**: NEW - Test artifact (static file, NOT generated)  
**Source**: `petstore-tests/Auth/PermissionEndpointFilter.cs`  
**Copied To**: `test-output/src/PetstoreApi/Filters/PermissionEndpointFilter.cs` (via gen:copy-test-stubs)  
**Purpose**: IEndpointFilter implementation that authorizes requests based on endpoint-to-policy mappings

**Generator Integration**: NONE - This is a static test artifact copied during test setup, not generated by templates

---

## Purpose

Implement `IEndpointFilter` to intercept ALL requests within a route group, retrieve the endpoint name from metadata, lookup the corresponding authorization policy, and enforce authorization before passing the request to the endpoint handler.

**Pattern**: Filter-based authorization without modifying generated endpoint code

---

## Implementation Structure

```csharp
using Microsoft.AspNetCore.Authorization;

namespace PetstoreApi.Filters;

/// <summary>
/// Endpoint filter that enforces authorization based on endpoint name to policy mapping
/// </summary>
public class PermissionEndpointFilter : IEndpointFilter
{
    private readonly IAuthorizationService _authorizationService;
    
    // Static mapping of endpoint names to policy names
    private static readonly Dictionary<string, string> EndpointPolicies = new()
    {
        // Pet endpoints
        { "AddPet", "WriteAccess" },
        { "UpdatePet", "WriteAccess" },
        { "DeletePet", "WriteAccess" },
        { "GetPetById", "ReadAccess" },
        { "FindPetsByStatus", "ReadAccess" },
        { "FindPetsByTags", "ReadAccess" },
        
        // Store endpoints
        { "PlaceOrder", "WriteAccess" },
        { "DeleteOrder", "WriteAccess" },
        { "GetOrderById", "ReadAccess" },
        { "GetInventory", "ReadAccess" },
        
        // User endpoints
        { "CreateUser", "WriteAccess" },
        { "UpdateUser", "WriteAccess" },
        { "DeleteUser", "WriteAccess" },
        { "GetUserByName", "ReadAccess" },
        { "LoginUser", "ReadAccess" },
        { "LogoutUser", "ReadAccess" }
    };
    
    public PermissionEndpointFilter(IAuthorizationService authorizationService)
    {
        _authorizationService = authorizationService ?? 
            throw new ArgumentNullException(nameof(authorizationService));
    }
    
    public async ValueTask<object?> InvokeAsync(
        EndpointFilterInvocationContext context, 
        EndpointFilterDelegate next)
    {
        var httpContext = context.HttpContext;
        
        // Retrieve endpoint name from metadata
        var endpointName = httpContext.GetEndpoint()?
            .Metadata
            .GetMetadata<EndpointNameMetadata>()?
            .EndpointName;
        
        // If no endpoint name or no policy mapping, allow request
        if (string.IsNullOrEmpty(endpointName) || 
            !EndpointPolicies.TryGetValue(endpointName, out var policyName))
        {
            return await next(context);
        }
        
        // Authorize based on policy
        var authorizationResult = await _authorizationService.AuthorizeAsync(
            httpContext.User, 
            resource: null, 
            policyName);
        
        // Return 403 Forbidden if authorization fails
        if (!authorizationResult.Succeeded)
        {
            return Results.Forbid();
        }
        
        // Authorization succeeded, continue to endpoint handler
        return await next(context);
    }
}
```

---

## Data Structure

### Input (Constructor)
- `IAuthorizationService authorizationService` - Injected from DI container

### Input (InvokeAsync)
- `EndpointFilterInvocationContext context` - Provides HttpContext and endpoint metadata
- `EndpointFilterDelegate next` - Next filter or endpoint handler in pipeline

### Output (InvokeAsync)
- `ValueTask<object?>` - Either:
  - `Results.Forbid()` (403 Forbidden) when authorization fails
  - `await next(context)` (continue pipeline) when authorization succeeds or no policy mapped

---

## Validation Rules

### 1. Constructor Validation
```csharp
public PermissionEndpointFilter(IAuthorizationService authorizationService)
{
    _authorizationService = authorizationService ?? 
        throw new ArgumentNullException(nameof(authorizationService));
}
```

**Requirements**:
- `IAuthorizationService` MUST NOT be null (throw `ArgumentNullException`)
- Registered in DI container via `builder.Services.AddAuthorization()`

### 2. Endpoint Name Retrieval
```csharp
var endpointName = httpContext.GetEndpoint()?
    .Metadata
    .GetMetadata<EndpointNameMetadata>()?
    .EndpointName;
```

**Requirements**:
- Safe navigation (`?.`) handles null endpoint or metadata
- Returns null if endpoint has no `.WithName()` metadata

### 3. Policy Lookup
```csharp
if (string.IsNullOrEmpty(endpointName) || 
    !EndpointPolicies.TryGetValue(endpointName, out var policyName))
{
    return await next(context);  // No policy = allow by default
}
```

**Requirements**:
- Empty/null endpoint names MUST be allowed (pass through)
- Unmapped endpoint names MUST be allowed (no policy enforcement)
- Only endpoints in `EndpointPolicies` dictionary are secured

### 4. Authorization Evaluation
```csharp
var authorizationResult = await _authorizationService.AuthorizeAsync(
    httpContext.User, 
    resource: null, 
    policyName);

if (!authorizationResult.Succeeded)
{
    return Results.Forbid();
}
```

**Requirements**:
- MUST use `IAuthorizationService.AuthorizeAsync()` (not manual claim checks)
- MUST pass `httpContext.User` for claim evaluation
- Resource parameter is `null` (policy doesn't require resource context)
- MUST return `Results.Forbid()` (403) on failure, NOT `Results.Unauthorized()` (401)

---

## Dependencies

### Framework Dependencies
- `Microsoft.AspNetCore.Authorization` (IAuthorizationService, IEndpointFilter)
- `Microsoft.AspNetCore.Http` (EndpointFilterInvocationContext, Results)
- `Microsoft.AspNetCore.Http.Metadata` (EndpointNameMetadata)

### Service Dependencies
- `IAuthorizationService` - Registered via `builder.Services.AddAuthorization()` in Program.cs

### Metadata Dependencies
- `EndpointNameMetadata` - Generated by `.WithName("EndpointName")` in endpoint registrations

---

## Usage Example

### Registration in Program.cs
```csharp
// 1. Register filter as singleton (stateless)
builder.Services.AddSingleton<PermissionEndpointFilter>();

// 2. Apply to route group via extension method (see AuthorizedEndpointExtensions.cs)
app.AddAuthorizedApiEndpoints();  // Internally applies .AddEndpointFilter<PermissionEndpointFilter>()
```

### Request Flow Example

**Scenario 1: Authorized Request**
```
1. POST /v2/pet with JWT containing "permission: write"
2. Filter retrieves endpoint name: "AddPet"
3. Filter looks up policy: EndpointPolicies["AddPet"] → "WriteAccess"
4. Filter calls: AuthorizeAsync(user, "WriteAccess")
5. Policy checks: user.HasClaim("permission", "write") → TRUE
6. Filter returns: await next(context) → Endpoint handler executes
7. Response: 201 Created
```

**Scenario 2: Unauthorized Request**
```
1. POST /v2/pet with JWT containing only "permission: read"
2. Filter retrieves endpoint name: "AddPet"
3. Filter looks up policy: EndpointPolicies["AddPet"] → "WriteAccess"
4. Filter calls: AuthorizeAsync(user, "WriteAccess")
5. Policy checks: user.HasClaim("permission", "write") → FALSE
6. Filter returns: Results.Forbid()
7. Response: 403 Forbidden (endpoint handler NEVER executes)
```

**Scenario 3: No Policy Mapping**
```
1. GET /health (hypothetical health check endpoint)
2. Filter retrieves endpoint name: "HealthCheck"
3. Filter looks up policy: EndpointPolicies["HealthCheck"] → NOT FOUND
4. Filter returns: await next(context) → Endpoint handler executes
5. Response: 200 OK (no authorization required)
```

---

## Testing Strategy

### Unit Tests (Filter Logic)
```csharp
[Fact]
public async Task InvokeAsync_EndpointWithWritePolicy_UserWithReadClaim_ReturnsForbidden()
{
    // Arrange
    var authService = CreateMockAuthService(authorizationSucceeds: false);
    var filter = new PermissionEndpointFilter(authService);
    var context = CreateMockContext("AddPet", claimValue: "read");
    
    // Act
    var result = await filter.InvokeAsync(context, next: _ => throw new Exception("Should not reach next"));
    
    // Assert
    result.Should().BeOfType<ForbidHttpResult>();
}

[Fact]
public async Task InvokeAsync_EndpointWithNoPolicy_AllowsRequest()
{
    // Arrange
    var authService = CreateMockAuthService();
    var filter = new PermissionEndpointFilter(authService);
    var context = CreateMockContext("UnmappedEndpoint", claimValue: "none");
    var nextCalled = false;
    
    // Act
    await filter.InvokeAsync(context, next: _ => { nextCalled = true; return default; });
    
    // Assert
    nextCalled.Should().BeTrue();
}
```

### Integration Tests (End-to-End)
See [Bruno test scenarios in quickstart.md]

---

## Future Enhancements

### 1. External Configuration
Load `EndpointPolicies` from JSON instead of hardcoded dictionary:
```csharp
public PermissionEndpointFilter(
    IAuthorizationService authorizationService,
    IConfiguration configuration)
{
    var endpointPolicies = configuration
        .GetSection("Authorization:EndpointPolicies")
        .Get<Dictionary<string, string>>() ?? new();
}
```

### 2. Wildcard Policies
Support pattern matching for endpoint names:
```csharp
{ "*Pet*", "WriteAccess" }  // All endpoints containing "Pet" require write access
```

### 3. Multiple Policies Per Endpoint
Support OR/AND logic:
```csharp
{ "AdminEndpoint", "AdminAccess|SuperUserAccess" }  // Either policy satisfies
```

### 4. Audit Logging
Log authorization failures:
```csharp
if (!authorizationResult.Succeeded)
{
    _logger.LogWarning("Authorization failed for endpoint {EndpointName}, user {User}", 
        endpointName, httpContext.User.Identity?.Name);
    return Results.Forbid();
}
```

---

## Generator Integration (Future)

### Mustache Template (permissionEndpointFilter.mustache)
```mustache
{{#useAuthentication}}
using Microsoft.AspNetCore.Authorization;

namespace {{{packageName}}}.Filters;

public class PermissionEndpointFilter : IEndpointFilter
{
    private readonly IAuthorizationService _authorizationService;
    
    private static readonly Dictionary<string, string> EndpointPolicies = new()
    {
        {{#apiInfo}}
        {{#apis}}
        {{#operations}}
        {{#operation}}
        { "{{{vendorExtensions.operationIdPascalCase}}}", "{{#vendorExtensions.x-requires-write}}WriteAccess{{/vendorExtensions.x-requires-write}}{{^vendorExtensions.x-requires-write}}ReadAccess{{/vendorExtensions.x-requires-write}}" }{{^-last}},{{/-last}}
        {{/operation}}
        {{/operations}}
        {{/apis}}
        {{/apiInfo}}
    };
    
    // ... implementation (same as above)
}
{{/useAuthentication}}
```

### OpenAPI Extension
```yaml
paths:
  /pet:
    post:
      x-requires-write: true  # Maps to WriteAccess policy
```

---

**Status**: Complete - Ready for implementation in test artifacts
